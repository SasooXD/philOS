#line(length: 100%)
#align(center, block[
	= Introduzione <introduzione>
	Le origini, le idee, lo sviluppo del progetto
])
#line(length: 100%)

Al giorno d’oggi l’informatica, nonostante sia essa un campo di ricerca e innovazione inconfondibilmente importante, dove sbarcano costantemente novità di ogni tipo e dove esiste sempre una grande quantità di programmi e sistemi in costante sviluppo e incessante aggiornamento, è divenuta sempre di più chiusa e intrappolata in una apparentemente immutabile presenza di codice a sorgente chiuso, software non libero e astrazioni su astrazioni di interfacce presentanti codice sconosciuto, mal funzionante, mal performante, ridondante. Le conseguenze provocano un *danno* consistente al programma finale, all’utente che lo deve usare e al programmatore che lo ha dovuto scrivere. Tornare indietro nel tempo per analizzare come l’informatica funzionava in un periodo dove la quantità di memoria e la capacità di calcolo erano una frazione di quelle attuali è un ottimo esperimento per migliorare poi la programmazione e la progettazione di sistemi moderni. Scoprire le intelligenti tattiche e le elusioni dei programmatori di una volta svela in modo più chiaro il *_low-level_*, vale a dire il basso livello: tutto ciò che è dietro le quinte di un computer, non visibile all’utente finale ma che è il vero cuore di tutto il sistema informatico.

Il processo che compie un programma nel suo più basso livello, anche se non visibile, è *fondamentale*. Il risultato finale in informatica non dovrebbe contare più di quanto un’applicazione sia ben strutturata: un applicativo che si presenta come ben fatto alla vista ma che non è codificato o strutturato bene, non rispetta delle particolari convenzioni, non considera tutti i casi d’uso o approssima dei risultati che dovrebbero essere precisi, è un programma che non usa la totalità del suo potenziale e la programmazione di quest’ultimo andrebbe assolutamente migliorata.

*_philOS_* è il nome dato ad un progetto che mira ad unire software e hardware, gestendo a tutto tondo il basso livello informatico. Per farlo, il sistema prende ispirazione dai vecchi computer creati principalmente da hobbisti attorno agli anni ’80 che hanno diffuso l’idea del *personal computer*: invenzione che ha normalizzato e reso disponibile in modo più facile a molte persone l’informatica, rendendola a sé stante, separata da materie scientifiche come la matematica o materie più tecniche come l’elettronica. Sviluppare questo progetto è stato un tuffo nella *storia dell’informatica*, ma anche un lavoro pratico per dimostrare le conoscenze teoriche imparate in tre anni di studio delle materie di indirizzo informatico, con una particolare enfasi su *sistemi e reti* e *telecomunicazioni*. Un viaggio per capire come funzionano i computer nel dettaglio e come si sono evoluti, fino ad arrivare ai giorni nostri.

Il nome è un gioco di parole: il termine greco antico _φίλος_, ovvero '_philos_' o '_filos_' si ritrova molto all’interno di parole composte nel suffisso -_filio_- o -_filia_-, che indicano propensione amorosa verso qualcosa, ad esempio nell’espressione '_fil_-sofo' o '_filo_-sofia' ('amore per la sapienza'). Segue poi l’acronimo 'OS' che in ambito informatico è spesso usato come abbreviazione per _operating system_ (sistema operativo).

Sebbene nasca come progetto esclusivamente logico (software), si evolve espandendosi anche nell’area fisica (hardware) dell’informatica, diventando un computer con software scritto e hardware progettato completamente da zero. _philOS_ è un computer a tutti gli effetti e che ha quindi richiesto un’ampia conoscenza di tutte le tematiche del mondo informatico ma che offre un’altrettanto ampia gamma di funzionalità dello stesso campo. Per farlo, come già introdotto in precedenza, _philOS_ si estende nel mondo del *basso livello* dell’informatica, astenendosi dall’uso di astrazioni comuni oggigiorno, sia per filosofia sia per ovvia limitatezza dovuta alla bassa capacità di calcolo dei suoi componenti, caratteristica che si nota altresí anche a livello di software.

Al cuore fisico di _philOS_ è un leggendario processore, classe 1978, l’*Intel 8086*;. La scelta di questo processore non è per niente casuale: l’i8086 è stato uno dei primi processori a *16 bit*;, uno dei primi grandi successi economici dell’Intel ma soprattutto il primo processore dell’*architettura x86* - ovvero l’insieme di istruzioni presente tutt’oggi (in versione chiaramente migliorata) nella maggior parte dei processori usati attualmente in un normale ambiente desktop. Il computer su cui è stato scritto questo documento, il server dove è caricato, il computer di chi lo sta leggendo è con molta probabilità composto da un processore che 'parla' la stessa lingua dell’unità di calcolo scelta per questo progetto, anche per questa ragione. La *retrocompatibilità teorica* di cui dispongono ancora le CPU odierne è stata necessaria nel corso della storia dei processori Intel in quanto l’x86 è una continua *evoluzione* di processori, ognuno con velocità e prestazioni sempre migliori, per cui al posto di abbandonare ogni processore ai pian piano sempre più antichi programmi che lo supportavano, si è scelto invece di continuare una catena di compatibilità che persiste tutt’oggi.

Sempre a livello hardware, una serie di altri componenti rendono il computer utilizzabile a tutti gli effetti, si notano, per citarne alcuni: le *memorie* (sia di sola lettura contenente i programmi sia quella volatile contenente i dati dei sopracitati); il *bus*;, il \"collegamento universale\" del computer, che fa interfacciare il processore a tutte le unità e *periferiche* esterne, inclusi un monitor e una tastiera; l’*oscillatore* (o _clock_;), che genera la continua \"pulsazione\" del cuore del processore assieme.

A livello di programmazione invece, è presente un piccolo *sistema operativo*, capace di far interagire gli utenti con i programmi in modo intuitivo e non enigmatico, così come una serie di altri *programmi* di base (calcolatrice, calcolatore della sequenza di Fibonacci, ecc.) e altri applicativi più complessi (usati per inviare o ricevere dati su porte, salvare i dati in memorie, ecc.).

#pagebreak()
